/**
 * Membership Practices Validators
 *
 * ESSENTIAL MODULES INTEGRATION:
 * - class-validator: Uses ValidatorConstraint for custom validation logic
 * - constants: Uses MEMBERSHIP_PRACTICES_FIELDS, limits, and patterns
 * - enums: Validates against local enums (ClientsAge, PracticeArea, PracticeSettings, PracticeServices)
 *
 * SIMPLIFICATION PHILOSOPHY:
 * - Essential validation only for OSOT practice data management
 * - Enum validation for all Choice fields (4 local multi-select + 2 global)
 * - Business rule validation (conditional _Other fields, required arrays)
 * - Practice ID format validation (osot-pra-0000001)
 */

import {
  ValidatorConstraint,
  ValidatorConstraintInterface,
  ValidationArguments,
} from 'class-validator';
import {
  PRACTICE_ID_PATTERN,
  MEMBERSHIP_PRACTICES_ENUMS,
  MEMBERSHIP_PRACTICES_BUSINESS_RULES,
} from '../constants/membership-practices.constants';
import { Privilege, AccessModifier } from '../../../../common/enums';
import { ClientsAge } from '../enums/clients-age.enum';
import { PracticeArea } from '../enums/practice-area.enum';
import { PracticeSettings } from '../enums/practice-settings.enum';
import { PracticeServices } from '../enums/practice-services.enum';

/**
 * Validator for Practice ID (Business ID)
 * Validates osot-pra-0000001 format based on CSV Autonumber specification
 *
 * NOTE: This field is auto-generated by Dataverse for normal operations.
 * This validator is primarily used for:
 * - Data migration from legacy systems
 * - Data integrity validation during bulk imports
 * - Testing scenarios with pre-defined IDs
 */
@ValidatorConstraint({ name: 'practiceId', async: false })
export class PracticeIdValidator implements ValidatorConstraintInterface {
  validate(practiceId: string): boolean {
    if (!practiceId) return true; // Optional for creation, required for updates

    // Validate format: osot-pra-0000001 (7 digits)
    return PRACTICE_ID_PATTERN.test(practiceId);
  }

  defaultMessage(): string {
    return 'Practice ID must follow format: osot-pra-0000001 (osot-pra followed by 7 digits)';
  }
}

/**
 * Validator for Membership Year
 * Validates integer field against year format and range
 * CRITICAL: This field is SYSTEM-DEFINED, validation here is for data integrity
 */
@ValidatorConstraint({ name: 'membershipYearPractices', async: false })
export class MembershipYearPracticesValidator
  implements ValidatorConstraintInterface
{
  validate(year: number | string): boolean {
    if (!year) return false; // Required field

    // Convert string to number if needed
    const yearNum = typeof year === 'string' ? parseInt(year, 10) : year;

    // Validate as integer
    if (!Number.isInteger(yearNum)) return false;

    // Check if within valid range
    return (
      yearNum >= MEMBERSHIP_PRACTICES_BUSINESS_RULES.MIN_YEAR &&
      yearNum <= MEMBERSHIP_PRACTICES_BUSINESS_RULES.MAX_YEAR
    );
  }

  defaultMessage(): string {
    return `Membership year must be an integer between ${MEMBERSHIP_PRACTICES_BUSINESS_RULES.MIN_YEAR} and ${MEMBERSHIP_PRACTICES_BUSINESS_RULES.MAX_YEAR}`;
  }
}

/**
 * Interface for conditional "Other" field validation
 */
interface ConditionalOtherValidationObject {
  osot_practice_settings?: PracticeSettings[];
  osot_practice_settings_other?: string;
  osot_practice_services?: PracticeServices[];
  osot_practice_services_other?: string;
}

/**
 * Validator for Practice Settings Other (Conditional)
 * Required when osot_practice_settings contains PracticeSettings.OTHER
 */
@ValidatorConstraint({ name: 'practiceSettingsOther', async: false })
export class PracticeSettingsOtherValidator
  implements ValidatorConstraintInterface
{
  validate(value: any, args?: ValidationArguments): boolean {
    if (!args?.object) return true;

    const object = args.object as ConditionalOtherValidationObject;
    const practiceSettings = object.osot_practice_settings;
    const practiceSettingsOther = object.osot_practice_settings_other;

    // If practice settings is an array and contains OTHER, then practice_settings_other is REQUIRED
    if (
      Array.isArray(practiceSettings) &&
      practiceSettings.includes(PracticeSettings.OTHER)
    ) {
      return !!(
        practiceSettingsOther &&
        typeof practiceSettingsOther === 'string' &&
        practiceSettingsOther.trim().length > 0
      );
    }

    // If practice settings does NOT contain OTHER, practice_settings_other should be empty/null
    return true;
  }

  defaultMessage(): string {
    return 'Practice settings other is required when practice settings includes OTHER';
  }
}

/**
 * Validator for Practice Services Other (Conditional)
 * Required when osot_practice_services contains PracticeServices.OTHER
 */
@ValidatorConstraint({ name: 'practiceServicesOther', async: false })
export class PracticeServicesOtherValidator
  implements ValidatorConstraintInterface
{
  validate(value: any, args?: ValidationArguments): boolean {
    if (!args?.object) return true;

    const object = args.object as ConditionalOtherValidationObject;
    const practiceServices = object.osot_practice_services;
    const practiceServicesOther = object.osot_practice_services_other;

    // If practice services is an array and contains OTHER, then practice_services_other is REQUIRED
    if (
      Array.isArray(practiceServices) &&
      practiceServices.includes(PracticeServices.OTHER)
    ) {
      return !!(
        practiceServicesOther &&
        typeof practiceServicesOther === 'string' &&
        practiceServicesOther.trim().length > 0
      );
    }

    // If practice services does NOT contain OTHER, practice_services_other should be empty/null
    return true;
  }

  defaultMessage(): string {
    return 'Practice services other is required when practice services includes OTHER';
  }
}

/**
 * Validator for Clients Age (Multi-select - REQUIRED)
 * Validates against ClientsAge enum - Multi-select with no duplicates
 * BUSINESS REQUIRED: Must have at least one value
 */
@ValidatorConstraint({ name: 'clientsAge', async: false })
export class ClientsAgeValidator implements ValidatorConstraintInterface {
  validate(clientsAge: number | number[]): boolean {
    if (clientsAge === null || clientsAge === undefined) return false; // Required field

    // Handle array (multi-select)
    if (Array.isArray(clientsAge)) {
      if (clientsAge.length === 0) return false; // Cannot be empty - BUSINESS REQUIRED

      // Check for duplicates
      const uniqueValues = new Set(clientsAge);
      if (uniqueValues.size !== clientsAge.length) return false;

      // Validate each value
      return clientsAge.every((value) =>
        MEMBERSHIP_PRACTICES_ENUMS.VALID_CLIENTS_AGES.includes(
          value as ClientsAge,
        ),
      );
    }

    // Handle single value (backward compatibility)
    return MEMBERSHIP_PRACTICES_ENUMS.VALID_CLIENTS_AGES.includes(
      clientsAge as ClientsAge,
    );
  }

  defaultMessage(): string {
    return 'Clients age must be a non-empty array of valid options with no duplicates';
  }
}

/**
 * Validator for Practice Area (Multi-select - OPTIONAL)
 * Validates against PracticeArea enum - Multi-select with no duplicates
 */
@ValidatorConstraint({ name: 'practiceArea', async: false })
export class PracticeAreaValidator implements ValidatorConstraintInterface {
  validate(practiceArea: number | number[] | undefined): boolean {
    // Optional field - allow null/undefined
    if (practiceArea === null || practiceArea === undefined) return true;

    // Handle array (multi-select)
    if (Array.isArray(practiceArea)) {
      // Empty array is valid for optional field
      if (practiceArea.length === 0) return true;

      // Check for duplicates
      const uniqueValues = new Set(practiceArea);
      if (uniqueValues.size !== practiceArea.length) return false;

      // Validate each value
      return practiceArea.every((value) =>
        MEMBERSHIP_PRACTICES_ENUMS.VALID_PRACTICE_AREAS.includes(
          value as PracticeArea,
        ),
      );
    }

    // Handle single value (backward compatibility)
    return MEMBERSHIP_PRACTICES_ENUMS.VALID_PRACTICE_AREAS.includes(
      practiceArea as PracticeArea,
    );
  }

  defaultMessage(): string {
    return 'Practice area must be an array of valid options with no duplicates';
  }
}

/**
 * Validator for Practice Settings (Multi-select - OPTIONAL)
 * Validates against PracticeSettings enum - Multi-select with no duplicates
 */
@ValidatorConstraint({ name: 'practiceSettings', async: false })
export class PracticeSettingsValidator implements ValidatorConstraintInterface {
  validate(practiceSettings: number | number[] | undefined): boolean {
    // Optional field - allow null/undefined
    if (practiceSettings === null || practiceSettings === undefined)
      return true;

    // Handle array (multi-select)
    if (Array.isArray(practiceSettings)) {
      // Empty array is valid for optional field
      if (practiceSettings.length === 0) return true;

      // Check for duplicates
      const uniqueValues = new Set(practiceSettings);
      if (uniqueValues.size !== practiceSettings.length) return false;

      // Validate each value
      return practiceSettings.every((value) =>
        MEMBERSHIP_PRACTICES_ENUMS.VALID_PRACTICE_SETTINGS.includes(
          value as PracticeSettings,
        ),
      );
    }

    // Handle single value (backward compatibility)
    return MEMBERSHIP_PRACTICES_ENUMS.VALID_PRACTICE_SETTINGS.includes(
      practiceSettings as PracticeSettings,
    );
  }

  defaultMessage(): string {
    return 'Practice settings must be an array of valid options with no duplicates';
  }
}

/**
 * Validator for Practice Services (Multi-select - OPTIONAL)
 * Validates against PracticeServices enum - Multi-select with no duplicates
 */
@ValidatorConstraint({ name: 'practiceServices', async: false })
export class PracticeServicesValidator implements ValidatorConstraintInterface {
  validate(practiceServices: number | number[] | undefined): boolean {
    // Optional field - allow null/undefined
    if (practiceServices === null || practiceServices === undefined)
      return true;

    // Handle array (multi-select)
    if (Array.isArray(practiceServices)) {
      // Empty array is valid for optional field
      if (practiceServices.length === 0) return true;

      // Check for duplicates
      const uniqueValues = new Set(practiceServices);
      if (uniqueValues.size !== practiceServices.length) return false;

      // Validate each value
      return practiceServices.every((value) =>
        MEMBERSHIP_PRACTICES_ENUMS.VALID_PRACTICE_SERVICES.includes(
          value as PracticeServices,
        ),
      );
    }

    // Handle single value (backward compatibility)
    return MEMBERSHIP_PRACTICES_ENUMS.VALID_PRACTICE_SERVICES.includes(
      practiceServices as PracticeServices,
    );
  }

  defaultMessage(): string {
    return 'Practice services must be an array of valid options with no duplicates';
  }
}

/**
 * Validator for Privilege (Single Choice)
 * Validates against Privilege enum
 */
@ValidatorConstraint({ name: 'privilegePractices', async: false })
export class PrivilegePracticesValidator
  implements ValidatorConstraintInterface
{
  validate(privilege: number | undefined): boolean {
    // Optional field - allow null/undefined
    if (privilege === null || privilege === undefined) return true;

    return MEMBERSHIP_PRACTICES_ENUMS.VALID_PRIVILEGES.includes(
      privilege as Privilege,
    );
  }

  defaultMessage(): string {
    return 'Privilege must be a valid option';
  }
}

/**
 * Validator for Access Modifier (Single Choice)
 * Validates against AccessModifier enum
 */
@ValidatorConstraint({ name: 'accessModifierPractices', async: false })
export class AccessModifierPracticesValidator
  implements ValidatorConstraintInterface
{
  validate(accessModifier: number | undefined): boolean {
    // Optional field - allow null/undefined
    if (accessModifier === null || accessModifier === undefined) return true;

    return MEMBERSHIP_PRACTICES_ENUMS.VALID_ACCESS_MODIFIERS.includes(
      accessModifier as AccessModifier,
    );
  }

  defaultMessage(): string {
    return 'Access modifier must be a valid option';
  }
}
