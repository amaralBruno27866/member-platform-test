# Identity Mappers

## Purpose

Contains specialized mapping utilities that transform data between layers with standardized error handling and type safety. Provides clean transformations between DTOs, internal interfaces, and Dataverse payloads while maintaining data integrity and security.

## Standards Compliance

✅ **Centralized Error Handling**: Uses `createAppError` and `ErrorCodes` from `/common/errors`
✅ **Centralized Enums**: Imports all enums from `/common/enums` index
✅ **Type Safety**: Comprehensive TypeScript interfaces and validation
✅ **Security Separation**: Clear distinction between internal and public data
✅ **Multi-Select Support**: Proper handling of Dataverse multi-select fields

## Mapper Functions Overview

### **Core Transformation Functions**

#### **`mapDataverseToIdentityInternal(raw): IdentityInternal`**

Transforms raw Dataverse data to internal interface with all fields including sensitive information.

- **Usage**: Internal processing only - never expose to public APIs
- **Features**: Flexible field name mapping, type validation, error handling
- **Security**: Includes privilege and sensitive fields for business logic

#### **`mapDataverseToIdentityResponse(raw): IdentityResponseDto`**

Transforms raw Dataverse data to public-safe response DTO.

- **Usage**: Public API responses and client-facing data
- **Features**: Sanitized output, consistent defaults, comprehensive validation
- **Security**: Safe for public consumption with business rule application

#### **`mapCreateDtoToDataversePayload(dto): Record<string, unknown>`**

Converts Create DTO to Dataverse API payload format.

- **Usage**: Creating new identity records via Dataverse API
- **Features**: Required field validation, optional field handling, read-only exclusion
- **Formats**: Language array to string conversion for multi-select fields

#### **`mapUpdateDtoToDataversePayload(dto): Record<string, unknown>`**

Converts Update DTO to Dataverse API payload format.

- **Usage**: Updating existing identity records
- **Features**: Selective field mapping, undefined field exclusion, system field protection
- **Optimization**: Only includes fields being updated

#### **`mapInternalToIdentityResponse(internal): IdentityResponseDto`**

Converts internal interface to public response DTO.

- **Usage**: Converting internal data structures to API-safe format
- **Features**: Sensitive field removal, format standardization
- **Security**: Controlled exposure of internal data

#### **`mapResponseToIdentityInternal(response): IdentityInternal`**

Converts response DTO back to internal interface for processing.

- **Usage**: When response data needs internal processing
- **Features**: Complete field mapping, format preservation
- **Context**: Service layer reprocessing scenarios

## Data Transformation Features

### **Multi-Select Field Handling**

```ts
// Helper Functions for Language Array Processing

/**
 * Parse Language enum arrays from Dataverse string format
 * Dataverse: "13,18" -> Internal: [13, 18]
 */
function parseLanguageArray(value: unknown): Language[];

/**
 * Convert Language array to Dataverse string format
 * Internal: [13, 18] -> Dataverse: "13,18"
 */
function languageArrayToString(languages: Language[]): string;
```

### **Enum Validation Helpers**

```ts
// Type-safe enum parsing with validation
function parseGender(value: unknown): Gender | undefined;
function parseRace(value: unknown): Race | undefined;
function parseIndigenousDetail(value: unknown): IndigenousDetail | undefined;
function parseAccessModifier(value: unknown): AccessModifier | undefined;
function parsePrivilege(value: unknown): Privilege | undefined;
```

### **Flexible Boolean Parsing**

```ts
// Handles multiple boolean representations
function parseBoolean(value: unknown): boolean | undefined;
// Supports: true/false, 1/0, "true"/"false", "1"/"0"
```

## Field Mapping Strategy

### **Flexible Field Name Resolution**

```ts
// Handles multiple Dataverse field name variations
const getString = (keys: string[]) => {
  for (const k of keys) {
    const v = r[k];
    if (typeof v === 'string') return v;
  }
  return undefined;
};

// Usage Examples:
osot_identity_id = getString([
  'osot_identity_id', // Standard format
  'osot_Identity_Id', // PascalCase variant
  'osotIdentityId', // CamelCase variant
]);
```

### **System Field Management**

```ts
// READ-ONLY FIELDS (excluded from create/update payloads):
// - osot_identity_id: Generated by Dataverse autonumber
// - osot_table_identityid: Generated by Dataverse as GUID
// - createdon/modifiedon: Managed by system
// - ownerid: Set by system based on authenticated user
```

### **Account Relationship Handling**

```ts
// Multiple relationship field variations
out.osot_table_account = getString([
  'osot_table_account', // Direct field
  'osot_Table_Account', // PascalCase variant
  '_osot_table_account_value', // Lookup value format
]);
```

## Error Handling Integration

### **Comprehensive Error Context**

```ts
// All mapper functions include detailed error handling
try {
  // Mapping logic...
  return result;
} catch (error) {
  if (error && typeof error === 'object' && 'code' in error) {
    // Re-throw our custom errors
    throw error;
  }
  throw createAppError(ErrorCodes.DATAVERSE_SERVICE_ERROR, {
    operation: 'map_dataverse_to_identity_internal',
    error: error instanceof Error ? error.message : 'Unknown mapping error',
    raw, // Include original data for debugging
  });
}
```

### **Input Validation**

```ts
// Strict validation of input parameters
if (!dto || typeof dto !== 'object') {
  throw createAppError(ErrorCodes.DATAVERSE_SERVICE_ERROR, {
    operation: 'map_create_dto_to_dataverse_payload',
    error: 'Invalid DTO provided - expected IdentityCreateDto object',
    dto,
  });
}
```

## Security Implementation

### **Internal vs Public Data Separation**

```ts
// INTERNAL INTERFACE (IdentityInternal)
// - Includes ALL fields including sensitive data
// - Used for business logic and internal processing
// - Never expose directly to public APIs

// PUBLIC RESPONSE (IdentityResponseDto)
// - Sanitized data safe for public consumption
// - Excludes sensitive internal metadata
// - Apply business rules for field visibility
```

### **Privilege Field Handling**

```ts
// Internal interface includes privilege for business logic
out.osot_privilege = parsePrivilege(r['osot_privilege']);

// Public response includes privilege but services should apply access control
dto.osot_privilege = internal.osot_privilege;
```

## Performance Optimizations

### **Selective Field Processing**

```ts
// Only process fields that exist in source data
if (dto.osot_chosen_name !== undefined) {
  payload.osot_chosen_name = dto.osot_chosen_name;
}
```

### **Efficient Enum Validation**

```ts
// Fast enum validation with fallback
return Object.values(Gender).includes(value) ? value : undefined;
```

### **Memory-Efficient Transformations**

```ts
// Direct field mapping without intermediate objects
const payload: Record<string, unknown> = {
  osot_user_business_id: dto.osot_user_business_id,
  osot_language: languageArrayToString(dto.osot_language),
};
```

## Usage Examples

### **Creating Identity Records**

```ts
// Transform create DTO to Dataverse payload
const createDto: IdentityCreateDto = {
  osot_user_business_id: 'user-123',
  osot_language: [Language.ENGLISH, Language.FRENCH],
  osot_gender: Gender.NON_BINARY,
  osot_privilege: Privilege.MEMBER,
};

const payload = mapCreateDtoToDataversePayload(createDto);
// Result: { osot_user_business_id: 'user-123', osot_language: '13,18', ... }
```

### **Processing Dataverse Response**

```ts
// Transform raw Dataverse data to typed response
const rawResponse = await dataverseService.getIdentity(id);
const identityResponse = mapDataverseToIdentityResponse(rawResponse);

// For internal processing with full data access
const internalData = mapDataverseToIdentityInternal(rawResponse);
```

### **Updating Identity Records**

```ts
// Selective update with only changed fields
const updateDto: IdentityUpdateDto = {
  osot_chosen_name: 'Alex',
  osot_access_modifiers: AccessModifier.PRIVATE,
};

const payload = mapUpdateDtoToDataversePayload(updateDto);
// Result: { osot_chosen_name: 'Alex', osot_access_modifiers: 1 }
// Note: Only includes fields being updated
```

### **Converting Between Formats**

```ts
// Internal to public conversion
const publicData = mapInternalToIdentityResponse(internalIdentity);

// Public back to internal (for reprocessing)
const internalData = mapResponseToIdentityInternal(publicResponse);
```

## Advanced Features

### **Language Array Processing**

```ts
// Input: Dataverse multi-select "13,18"
const languages = parseLanguageArray('13,18');
// Output: [Language.ENGLISH, Language.FRENCH]

// Input: Internal array [13, 18]
const dataverseFormat = languageArrayToString([13, 18]);
// Output: "13,18"
```

### **Flexible Type Handling**

```ts
// Handles multiple input formats for enums
parseGender(1); // number -> Gender.MALE
parseGender('1'); // string -> Gender.MALE
parseGender('invalid'); // invalid -> undefined
```

### **Boolean Flexibility**

```ts
// Multiple boolean representations supported
parseBoolean(true); // boolean -> true
parseBoolean(1); // number -> true
parseBoolean('true'); // string -> true
parseBoolean('1'); // string -> true
parseBoolean(0); // number -> false
parseBoolean('false'); // string -> false
```

## Architecture Benefits

### **Type Safety**

- Comprehensive TypeScript interfaces for all transformations
- Compile-time validation of data structures
- Runtime enum validation with fallbacks

### **Error Resilience**

- Graceful handling of missing or malformed data
- Detailed error context for debugging
- Consistent error patterns across all mappers

### **Security by Design**

- Clear separation between internal and public data
- Controlled exposure of sensitive information
- Privilege-based field access patterns

### **Maintainability**

- Pure functions without side effects
- Centralized transformation logic
- Consistent patterns across all mappers

### **Performance Ready**

- Efficient field processing
- Memory-conscious transformations
- Minimal object creation overhead

## Best Practices

1. **Data Validation**: Always validate input parameters before processing
2. **Error Context**: Provide meaningful error messages with operation context
3. **Type Safety**: Use TypeScript interfaces for compile-time validation
4. **Security**: Never expose IdentityInternal to public APIs
5. **Performance**: Use selective field processing for large datasets
6. **Consistency**: Follow established patterns for all transformation functions
7. **Enum Usage**: Always use centralized enum imports and validation
8. **Field Names**: Handle multiple Dataverse field name variations gracefully
