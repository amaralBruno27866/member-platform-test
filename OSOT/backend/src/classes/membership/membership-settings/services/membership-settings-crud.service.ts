/**
 * Membership Settings CRUD Service (CLEAN REBUILD)
 *
 * ESSENTIAL MODULES INTEGRATION:
 * - Repository Pattern: Clean data access abstraction with DataverseMembershipSettingsRepository
 * - Structured Logging: Operation IDs, security-aware logging
 * - Security-First Design: Admin/Main privilege requirement for CUD operations
 * - Data Transformation: Mappers for DTO â†” Internal conversions
 * - Error Management: Centralized error handling with ErrorCodes
 *
 * PERMISSION SYSTEM (Membership Settings Specific):
 * - ADMIN (privilege = 2): Full CRUD access to all membership settings operations
 * - MAIN (privilege = 3): Full CRUD access to all membership settings operations
 * - PUBLIC ACCESS: No direct CRUD access (handled via lookup service)
 * - OTHER PRIVILEGES: No CRUD access
 *
 * ENTERPRISE FEATURES:
 * - Operation tracking with unique IDs for audit trails
 * - Privilege-based access control with admin/main requirement
 * - Comprehensive business rule validation
 * - Automatic data transformation and sanitization
 * - Business ID generation for new settings
 *
 * Key Features:
 * - Admin/Main privilege requirement for all CUD operations
 * - Category-year uniqueness enforcement
 * - Comprehensive fee and date validation
 * - Business ID auto-generation with format osot-set-XXXXXXX
 * - Soft delete functionality (sets status to INACTIVE)
 * - Operation tracking for compliance and debugging
 */

import { Injectable, Inject, Logger } from '@nestjs/common';
import { CreateMembershipSettingsDto } from '../dtos/membership-settings-create.dto';
import { UpdateMembershipSettingsDto } from '../dtos/membership-settings-update.dto';
import { MembershipSettingsResponseDto } from '../dtos/membership-settings-response.dto';
import {
  DataverseMembershipSettingsRepository,
  MEMBERSHIP_SETTINGS_REPOSITORY,
} from '../repositories/membership-settings.repository';
import { MembershipSettingsMapper } from '../mappers/membership-settings.mapper';
import { createAppError } from '../../../../common/errors/error.factory';
import { Privilege } from '../../../../common/enums';
import {
  MEMBERSHIP_SETTINGS_DEFAULTS,
  MEMBERSHIP_SETTINGS_ERROR_CODES,
} from '../constants/membership-settings.constants';

@Injectable()
export class MembershipSettingsCrudService {
  private readonly logger = new Logger(MembershipSettingsCrudService.name);

  constructor(
    @Inject(MEMBERSHIP_SETTINGS_REPOSITORY)
    private readonly repository: DataverseMembershipSettingsRepository,
  ) {}

  /**
   * Create new membership settings (Admin/Main only)
   * @param dto - Creation data
   * @param organizationGuid - REQUIRED: Organization GUID from JWT context (multi-tenant isolation)
   * @param userPrivilege - User privilege level for access control
   * @param operationId - Optional operation ID for tracking
   */
  async create(
    dto: CreateMembershipSettingsDto,
    organizationGuid: string,
    userPrivilege?: Privilege,
    operationId?: string,
  ): Promise<MembershipSettingsResponseDto> {
    const opId = operationId || `create-${Date.now()}`;
    this.logger.log(`Creating membership settings for operation ${opId}`);

    try {
      // Privilege validation - only Main can create
      if (!this.canCreateSettings(userPrivilege)) {
        throw createAppError(
          MEMBERSHIP_SETTINGS_ERROR_CODES.PERMISSION_DENIED,
          {
            message:
              'Insufficient privileges: Main privilege required for creation',
            operationId: opId,
            requiredPrivilege: 'Main',
            userPrivilege: userPrivilege || 'None',
          },
        );
      }

      // Transform DTO to internal format (with organization context from JWT)
      const internal = MembershipSettingsMapper.mapCreateDtoToInternal(
        dto,
        organizationGuid,
      );

      // Apply defaults for system fields
      internal.osot_privilege =
        internal.osot_privilege || MEMBERSHIP_SETTINGS_DEFAULTS.PRIVILEGE;
      internal.osot_access_modifiers =
        internal.osot_access_modifiers ||
        MEMBERSHIP_SETTINGS_DEFAULTS.ACCESS_MODIFIERS;

      // Note: osot_settingsid is auto-generated by Dataverse (Autonumber field)
      // Do not set it manually - let Dataverse handle the auto-generation

      // Create in repository
      const created = await this.repository.create(internal);

      // Transform to response DTO
      const response =
        MembershipSettingsMapper.mapInternalToResponseDto(created);

      this.logger.log(
        `Successfully created membership settings ${created.osot_settingsid} for operation ${opId}`,
      );
      return response;
    } catch (error) {
      this.logger.error('Failed to create membership settings', {
        operationId: opId,
        error: error instanceof Error ? error.message : 'Unknown error',
      });

      throw createAppError(MEMBERSHIP_SETTINGS_ERROR_CODES.INTERNAL_ERROR, {
        context: { operationId: opId },
        originalError:
          error instanceof Error ? error : new Error('Unknown error'),
      });
    }
  }

  /**
   * Update existing membership settings (Admin/Main only)
   * @param settingsId - ID of settings to update
   * @param dto - Update data
   * @param organizationGuid - REQUIRED: Organization GUID from JWT context (for multi-tenant validation)
   * @param userPrivilege - User privilege level for access control
   * @param operationId - Optional operation ID for tracking
   */
  async update(
    settingsId: string,
    dto: UpdateMembershipSettingsDto,
    organizationGuid: string,
    userPrivilege?: Privilege,
    operationId?: string,
  ): Promise<MembershipSettingsResponseDto> {
    const opId = operationId || `update-${Date.now()}`;
    this.logger.log(
      `Updating membership settings ${settingsId} for operation ${opId}`,
    );

    try {
      // Privilege validation - Admin and Main can update
      if (!this.canUpdateSettings(userPrivilege)) {
        throw createAppError(
          MEMBERSHIP_SETTINGS_ERROR_CODES.PERMISSION_DENIED,
          {
            message:
              'Insufficient privileges: Admin or Main privilege required for update',
            operationId: opId,
            settingsId,
            requiredPrivilege: 'Admin or Main',
            userPrivilege: userPrivilege || 'None',
          },
        );
      }

      // Check if record exists
      const existing = await this.repository.findBySettingsId(
        organizationGuid,
        settingsId,
      );
      if (!existing) {
        throw createAppError(MEMBERSHIP_SETTINGS_ERROR_CODES.NOT_FOUND, {
          message: `Membership settings not found: ${settingsId}`,
          operationId: opId,
          settingsId,
        });
      }

      // MULTI-TENANT VALIDATION: Ensure record belongs to the organization
      if (existing.organizationGuid !== organizationGuid) {
        throw createAppError(
          MEMBERSHIP_SETTINGS_ERROR_CODES.PERMISSION_DENIED,
          {
            message:
              'Cannot modify settings from different organization (multi-tenant violation)',
            operationId: opId,
            settingsId,
            providedOrganization: organizationGuid,
            recordOrganization: existing.organizationGuid,
          },
        );
      }

      // Transform DTO to internal format (preserving existing organization)
      const updateData = MembershipSettingsMapper.mapUpdateDtoToInternal(
        dto,
        organizationGuid,
      );

      // Update in repository (pass organizationGuid)
      const updated = await this.repository.update(
        organizationGuid,
        settingsId,
        updateData,
      );

      // Transform to response DTO
      const response =
        MembershipSettingsMapper.mapInternalToResponseDto(updated);

      this.logger.log(
        `Successfully updated membership settings ${settingsId} for operation ${opId}`,
      );
      return response;
    } catch (error) {
      this.logger.error('Failed to update membership settings', error);

      throw createAppError(MEMBERSHIP_SETTINGS_ERROR_CODES.INTERNAL_ERROR, {
        message: 'Failed to update membership settings',
        operationId: opId,
        settingsId,
        originalError: error instanceof Error ? error.message : String(error),
      });
    }
  }

  /**
   * Soft delete membership settings (Admin/Main only)
   * @param settingsId - ID to delete
   * @param organizationGuid - REQUIRED: Organization GUID from JWT context (multi-tenant isolation)
   * @param userPrivilege - User privilege level for access control
   * @param operationId - Optional operation ID for tracking
   */
  async delete(
    settingsId: string,
    organizationGuid: string,
    userPrivilege?: Privilege,
    operationId?: string,
  ): Promise<boolean> {
    const opId = operationId || `delete-${Date.now()}`;
    this.logger.log(
      `Deleting membership settings ${settingsId} for operation ${opId}`,
    );

    try {
      // Privilege validation - Only Main can delete
      if (!this.canDeleteSettings(userPrivilege)) {
        throw createAppError(
          MEMBERSHIP_SETTINGS_ERROR_CODES.PERMISSION_DENIED,
          {
            message:
              'Insufficient privileges: Main privilege required for deletion',
            operationId: opId,
            settingsId,
            requiredPrivilege: 'Main',
            userPrivilege: userPrivilege || 'None',
          },
        );
      }

      // Soft delete by setting status to INACTIVE (pass organizationGuid)
      const result = await this.repository.delete(organizationGuid, settingsId);

      if (!result) {
        throw createAppError(MEMBERSHIP_SETTINGS_ERROR_CODES.NOT_FOUND, {
          message: `Membership settings not found: ${settingsId}`,
          operationId: opId,
          settingsId,
        });
      }

      this.logger.log(
        `Successfully deleted membership settings ${settingsId} for operation ${opId}`,
      );
      return result;
    } catch (error) {
      this.logger.error(
        `Error deleting membership settings ${settingsId} for operation ${opId}:`,
        error,
      );

      throw createAppError(MEMBERSHIP_SETTINGS_ERROR_CODES.INTERNAL_ERROR, {
        message: 'Failed to delete membership settings',
        operationId: opId,
        settingsId,
        originalError: error instanceof Error ? error.message : String(error),
      });
    }
  }

  /**
   * Check if user can create membership settings
   * Only Main privilege can create
   */
  private canCreateSettings(userPrivilege?: Privilege): boolean {
    return userPrivilege === Privilege.MAIN;
  }

  /**
   * Check if user can update membership settings
   * Admin and Main privileges can update
   */
  private canUpdateSettings(userPrivilege?: Privilege): boolean {
    return (
      userPrivilege === Privilege.ADMIN || userPrivilege === Privilege.MAIN
    );
  }

  /**
   * Check if user can delete membership settings
   * Only Main privilege can delete
   */
  private canDeleteSettings(userPrivilege?: Privilege): boolean {
    return userPrivilege === Privilege.MAIN;
  }

  /**
   * Check if user can modify membership settings (backward compatibility)
   */
  private canModifySettings(userPrivilege?: Privilege): boolean {
    return (
      userPrivilege === Privilege.ADMIN || userPrivilege === Privilege.MAIN
    );
  }
}
