/**
 * Membership Employment Validators
 *
 * ESSENTIAL MODULES INTEGRATION:
 * - class-validator: Uses ValidatorConstraint for custom validation logic
 * - constants: Uses MEMBERSHIP_EMPLOYMENT_FIELDS, limits, and patterns
 * - enums: Validates against local enums (Benefits, Funding, etc.) and global enums
 *
 * SIMPLIFICATION PHILOSOPHY:
 * - Essential validation only for OSOT employment data management
 * - CSV field constraint validation based on Dataverse specifications
 * - Enum validation for all Choice fields (7 local + 2 global)
 * - Business rule validation (conditional _Other fields, user-year uniqueness)
 * - Employment ID format validation (osot-emp-0000001)
 */

import {
  ValidatorConstraint,
  ValidatorConstraintInterface,
  ValidationArguments,
} from 'class-validator';
import {
  EMPLOYMENT_ID_PATTERN,
  MEMBERSHIP_EMPLOYMENT_ENUMS,
  MEMBERSHIP_EMPLOYMENT_BUSINESS_RULES,
} from '../constants/membership-employment.constants';
import { Privilege, AccessModifier } from '../../../../common/enums';
import { Benefits } from '../enums/benefits.enum';
import { EmploymentStatus } from '../enums/employment-status.enum';
import { Funding } from '../enums/funding.enum';
import { HourlyEarnings } from '../enums/hourly-earnings.enum';
import { PracticeYears } from '../enums/practice-years.enum';
import { RoleDescription } from '../enums/role-descriptor.enum';
import { WorkHours } from '../enums/work-hours.enum';

/**
 * Validator for Employment ID (Business ID)
 * Validates osot-emp-0000001 format based on CSV Autonumber specification
 *
 * NOTE: This field is auto-generated by Dataverse for normal operations.
 * This validator is primarily used for:
 * - Data migration from legacy systems
 * - Data integrity validation during bulk imports
 * - Testing scenarios with pre-defined IDs
 */
@ValidatorConstraint({ name: 'employmentId', async: false })
export class EmploymentIdValidator implements ValidatorConstraintInterface {
  validate(employmentId: string): boolean {
    if (!employmentId) return true; // Optional for creation, required for updates

    // Validate format: osot-emp-0000001 (7 digits)
    return EMPLOYMENT_ID_PATTERN.test(employmentId);
  }

  defaultMessage(): string {
    return 'Employment ID must follow format: osot-emp-0000001 (osot-emp followed by 7 digits)';
  }
}

/**
 * Validator for Membership Year
 * Validates integer field against year format and range
 * CRITICAL: This field is SYSTEM-DEFINED, validation here is for data integrity
 */
@ValidatorConstraint({ name: 'membershipYearEmployment', async: false })
export class MembershipYearEmploymentValidator
  implements ValidatorConstraintInterface
{
  validate(year: number): boolean {
    if (!year) return false; // Required field

    // Validate as integer
    if (!Number.isInteger(year)) return false;

    // Check if within valid range
    return (
      year >= MEMBERSHIP_EMPLOYMENT_BUSINESS_RULES.MIN_YEAR &&
      year <= MEMBERSHIP_EMPLOYMENT_BUSINESS_RULES.MAX_YEAR
    );
  }

  defaultMessage(): string {
    return `Membership year must be an integer between ${MEMBERSHIP_EMPLOYMENT_BUSINESS_RULES.MIN_YEAR} and ${MEMBERSHIP_EMPLOYMENT_BUSINESS_RULES.MAX_YEAR}`;
  }
}

/**
 * Interface for lookup validation arguments
 */
interface LookupValidationObject {
  osot_table_account?: string;
  osot_table_account_affiliate?: string;
  ['osot_Table_Account@odata.bind']?: string;
  ['osot_Table_Account_Affiliate@odata.bind']?: string;
}

/**
 * Validator for Exclusive User Reference
 * Ensures only ONE of Account OR Affiliate is specified, never both
 */
@ValidatorConstraint({ name: 'exclusiveUserReferenceEmployment', async: false })
export class ExclusiveUserReferenceEmploymentValidator
  implements ValidatorConstraintInterface
{
  validate(value: any, args?: ValidationArguments): boolean {
    if (!args?.object) return false;

    const object = args.object as LookupValidationObject;

    // Check both regular fields and OData bind fields
    const accountBind = object['osot_Table_Account@odata.bind'];
    const affiliateBind = object['osot_Table_Account_Affiliate@odata.bind'];
    const accountId = object.osot_table_account;
    const affiliateId = object.osot_table_account_affiliate;

    // Check if account is present (either bind or direct)
    const hasAccount =
      (accountBind &&
        typeof accountBind === 'string' &&
        accountBind.trim().length > 0) ||
      (accountId &&
        typeof accountId === 'string' &&
        accountId.trim().length > 0);

    // Check if affiliate is present (either bind or direct)
    const hasAffiliate =
      (affiliateBind &&
        typeof affiliateBind === 'string' &&
        affiliateBind.trim().length > 0) ||
      (affiliateId &&
        typeof affiliateId === 'string' &&
        affiliateId.trim().length > 0);

    // XOR logic: Account and Affiliate are mutually exclusive
    // Both false (neither) is OK for DTOs, both true is NOT OK
    return !(hasAccount && hasAffiliate);
  }

  defaultMessage(): string {
    return 'Cannot specify both Account and Affiliate - only one user reference is allowed';
  }
}

/**
 * Validator for Lookup Requirements
 * Ensures at least one user reference (Account OR Affiliate) is populated
 * Account and Affiliate are mutually exclusive (validated separately)
 */
@ValidatorConstraint({ name: 'userLookupRequired', async: false })
export class UserLookupRequiredValidator
  implements ValidatorConstraintInterface
{
  validate(value: any, args?: ValidationArguments): boolean {
    if (!args?.object) return false;

    const validationObject = args.object as LookupValidationObject;
    const {
      osot_table_account: accountId,
      osot_table_account_affiliate: affiliateId,
    } = validationObject;

    // Also check OData bind fields
    const accountBind = validationObject['osot_Table_Account@odata.bind'];
    const affiliateBind =
      validationObject['osot_Table_Account_Affiliate@odata.bind'];

    // At least one user reference must be present
    const hasAccount =
      (accountBind && accountBind.trim().length > 0) ||
      (accountId && accountId.trim().length > 0);
    const hasAffiliate =
      (affiliateBind && affiliateBind.trim().length > 0) ||
      (affiliateId && affiliateId.trim().length > 0);

    return hasAccount || hasAffiliate;
  }

  defaultMessage(): string {
    return 'At least one user reference must be provided (account or affiliate)';
  }
}

/**
 * Interface for conditional "Other" field validation
 */
interface ConditionalOtherValidationObject {
  osot_role_descriptor?: RoleDescription;
  osot_role_descriptor_other?: string;
  osot_position_funding?: Funding[];
  osot_position_funding_other?: string;
  osot_employment_benefits?: Benefits[];
  osot_employment_benefits_other?: string;
}

/**
 * Validator for Role Descriptor Other (Conditional)
 * Required when osot_role_descriptor = RoleDescription.OTHER
 */
@ValidatorConstraint({ name: 'roleDescriptorOther', async: false })
export class RoleDescriptorOtherValidator
  implements ValidatorConstraintInterface
{
  validate(value: any, args?: ValidationArguments): boolean {
    if (!args?.object) return true;

    const object = args.object as ConditionalOtherValidationObject;
    const roleDescriptor = object.osot_role_descriptor;
    const roleDescriptorOther = object.osot_role_descriptor_other;

    // If role descriptor is OTHER, then role_descriptor_other is REQUIRED
    if (roleDescriptor === RoleDescription.OTHER) {
      return !!(
        roleDescriptorOther &&
        typeof roleDescriptorOther === 'string' &&
        roleDescriptorOther.trim().length > 0
      );
    }

    // If role descriptor is NOT OTHER, role_descriptor_other should be empty/null
    // (This is optional - you can allow it to be present but it will be ignored)
    return true;
  }

  defaultMessage(): string {
    return 'Role descriptor other is required when role descriptor is set to OTHER';
  }
}

/**
 * Validator for Position Funding Other (Conditional)
 * Required when osot_position_funding contains Funding.OTHER
 */
@ValidatorConstraint({ name: 'positionFundingOther', async: false })
export class PositionFundingOtherValidator
  implements ValidatorConstraintInterface
{
  validate(value: any, args?: ValidationArguments): boolean {
    if (!args?.object) return true;

    const object = args.object as ConditionalOtherValidationObject;
    const positionFunding = object.osot_position_funding;
    const positionFundingOther = object.osot_position_funding_other;

    // If position funding is an array and contains OTHER, then position_funding_other is REQUIRED
    if (
      Array.isArray(positionFunding) &&
      positionFunding.includes(Funding.OTHER)
    ) {
      return !!(
        positionFundingOther &&
        typeof positionFundingOther === 'string' &&
        positionFundingOther.trim().length > 0
      );
    }

    // If position funding does NOT contain OTHER, position_funding_other should be empty/null
    return true;
  }

  defaultMessage(): string {
    return 'Position funding other is required when position funding includes OTHER';
  }
}

/**
 * Validator for Employment Benefits Other (Conditional)
 * Required when osot_employment_benefits contains Benefits.OTHER
 */
@ValidatorConstraint({ name: 'employmentBenefitsOther', async: false })
export class EmploymentBenefitsOtherValidator
  implements ValidatorConstraintInterface
{
  validate(value: any, args?: ValidationArguments): boolean {
    if (!args?.object) return true;

    const object = args.object as ConditionalOtherValidationObject;
    const employmentBenefits = object.osot_employment_benefits;
    const employmentBenefitsOther = object.osot_employment_benefits_other;

    // If employment benefits is an array and contains OTHER, then employment_benefits_other is REQUIRED
    if (
      Array.isArray(employmentBenefits) &&
      employmentBenefits.includes(Benefits.OTHER)
    ) {
      return !!(
        employmentBenefitsOther &&
        typeof employmentBenefitsOther === 'string' &&
        employmentBenefitsOther.trim().length > 0
      );
    }

    // If employment benefits does NOT contain OTHER, employment_benefits_other should be empty/null
    return true;
  }

  defaultMessage(): string {
    return 'Employment benefits other is required when employment benefits includes OTHER';
  }
}

/**
 * Validator for Work Hours (Multi-select)
 * Validates against WorkHours enum - Multi-select with no duplicates
 */
@ValidatorConstraint({ name: 'workHours', async: false })
export class WorkHoursValidator implements ValidatorConstraintInterface {
  validate(workHours: number | number[]): boolean {
    if (workHours === null || workHours === undefined) return false; // Required field

    // Handle array (multi-select)
    if (Array.isArray(workHours)) {
      if (workHours.length === 0) return false; // Cannot be empty

      // Check for duplicates
      const uniqueValues = new Set(workHours);
      if (uniqueValues.size !== workHours.length) return false;

      // Validate each value
      return workHours.every((value) =>
        MEMBERSHIP_EMPLOYMENT_ENUMS.VALID_WORK_HOURS.includes(
          value as WorkHours,
        ),
      );
    }

    // Handle single value (backward compatibility)
    return MEMBERSHIP_EMPLOYMENT_ENUMS.VALID_WORK_HOURS.includes(
      workHours as WorkHours,
    );
  }

  defaultMessage(): string {
    return 'Work hours must be a non-empty array of valid options with no duplicates';
  }
}

/**
 * Validator for Position Funding (Multi-select)
 * Validates against Funding enum - Multi-select with no duplicates
 */
@ValidatorConstraint({ name: 'positionFunding', async: false })
export class PositionFundingValidator implements ValidatorConstraintInterface {
  validate(positionFunding: number | number[]): boolean {
    if (positionFunding === null || positionFunding === undefined) return false; // Required field

    // Handle array (multi-select)
    if (Array.isArray(positionFunding)) {
      if (positionFunding.length === 0) return false; // Cannot be empty

      // Check for duplicates
      const uniqueValues = new Set(positionFunding);
      if (uniqueValues.size !== positionFunding.length) return false;

      // Validate each value
      return positionFunding.every((value) =>
        MEMBERSHIP_EMPLOYMENT_ENUMS.VALID_FUNDING_SOURCES.includes(
          value as Funding,
        ),
      );
    }

    // Handle single value (backward compatibility)
    return MEMBERSHIP_EMPLOYMENT_ENUMS.VALID_FUNDING_SOURCES.includes(
      positionFunding as Funding,
    );
  }

  defaultMessage(): string {
    return 'Position funding must be a non-empty array of valid options with no duplicates';
  }
}

/**
 * Validator for Employment Benefits (Multi-select)
 * Validates against Benefits enum - Multi-select with no duplicates
 */
@ValidatorConstraint({ name: 'employmentBenefits', async: false })
export class EmploymentBenefitsValidator
  implements ValidatorConstraintInterface
{
  validate(employmentBenefits: number | number[]): boolean {
    if (employmentBenefits === null || employmentBenefits === undefined)
      return false; // Required field

    // Handle array (multi-select)
    if (Array.isArray(employmentBenefits)) {
      if (employmentBenefits.length === 0) return false; // Cannot be empty

      // Check for duplicates
      const uniqueValues = new Set(employmentBenefits);
      if (uniqueValues.size !== employmentBenefits.length) return false;

      // Validate each value
      return employmentBenefits.every((value) =>
        MEMBERSHIP_EMPLOYMENT_ENUMS.VALID_BENEFITS.includes(value as Benefits),
      );
    }

    // Handle single value (backward compatibility)
    return MEMBERSHIP_EMPLOYMENT_ENUMS.VALID_BENEFITS.includes(
      employmentBenefits as Benefits,
    );
  }

  defaultMessage(): string {
    return 'Employment benefits must be a non-empty array of valid options with no duplicates';
  }
}

/**
 * Validator for Employment Status (Single Choice)
 * Validates against EmploymentStatus enum
 */
@ValidatorConstraint({ name: 'employmentStatus', async: false })
export class EmploymentStatusValidator implements ValidatorConstraintInterface {
  validate(employmentStatus: number): boolean {
    if (employmentStatus === null || employmentStatus === undefined)
      return false; // Required field

    return MEMBERSHIP_EMPLOYMENT_ENUMS.VALID_EMPLOYMENT_STATUSES.includes(
      employmentStatus as EmploymentStatus,
    );
  }

  defaultMessage(): string {
    return 'Employment status must be a valid option';
  }
}

/**
 * Validator for Role Descriptor (Single Choice)
 * Validates against RoleDescription enum
 */
@ValidatorConstraint({ name: 'roleDescriptor', async: false })
export class RoleDescriptorValidator implements ValidatorConstraintInterface {
  validate(roleDescriptor: number): boolean {
    if (roleDescriptor === null || roleDescriptor === undefined) return false; // Required field

    return MEMBERSHIP_EMPLOYMENT_ENUMS.VALID_ROLE_DESCRIPTORS.includes(
      roleDescriptor as RoleDescription,
    );
  }

  defaultMessage(): string {
    return 'Role descriptor must be a valid option';
  }
}

/**
 * Validator for Practice Years (Single Choice)
 * Validates against PracticeYears enum
 */
@ValidatorConstraint({ name: 'practiceYears', async: false })
export class PracticeYearsValidator implements ValidatorConstraintInterface {
  validate(practiceYears: number): boolean {
    if (practiceYears === null || practiceYears === undefined) return false; // Required field

    return MEMBERSHIP_EMPLOYMENT_ENUMS.VALID_PRACTICE_YEARS.includes(
      practiceYears as PracticeYears,
    );
  }

  defaultMessage(): string {
    return 'Practice years must be a valid option';
  }
}

/**
 * Validator for Hourly Earnings (Single Choice)
 * Validates against HourlyEarnings enum - used for all 3 earnings fields
 */
@ValidatorConstraint({ name: 'hourlyEarnings', async: false })
export class HourlyEarningsValidator implements ValidatorConstraintInterface {
  validate(hourlyEarnings: number): boolean {
    if (hourlyEarnings === null || hourlyEarnings === undefined) return false; // Required field

    return MEMBERSHIP_EMPLOYMENT_ENUMS.VALID_HOURLY_EARNINGS.includes(
      hourlyEarnings as HourlyEarnings,
    );
  }

  defaultMessage(): string {
    return 'Hourly earnings must be a valid option';
  }
}

/**
 * Validator for Privilege
 * Validates against Privilege enum (Owner, Admin, Main)
 */
@ValidatorConstraint({ name: 'privilegeEmployment', async: false })
export class PrivilegeEmploymentValidator
  implements ValidatorConstraintInterface
{
  validate(privilege: number): boolean {
    if (privilege === null || privilege === undefined) return true; // Optional field

    return MEMBERSHIP_EMPLOYMENT_ENUMS.VALID_PRIVILEGES.includes(
      privilege as Privilege,
    );
  }

  defaultMessage(): string {
    return 'Privilege must be a valid privilege level from the available options';
  }
}

/**
 * Validator for Access Modifiers
 * Validates against AccessModifier enum (Private, Public, etc.)
 */
@ValidatorConstraint({ name: 'accessModifiersEmployment', async: false })
export class AccessModifiersEmploymentValidator
  implements ValidatorConstraintInterface
{
  validate(accessModifier: number): boolean {
    if (accessModifier === null || accessModifier === undefined) return true; // Optional field

    return MEMBERSHIP_EMPLOYMENT_ENUMS.VALID_ACCESS_MODIFIERS.includes(
      accessModifier as AccessModifier,
    );
  }

  defaultMessage(): string {
    return 'Access modifiers must be a valid access modifier from the available options';
  }
}

/**
 * Validator for Membership Year Immutability
 * Ensures membership_year cannot be changed after creation (UPDATE operations)
 */
@ValidatorConstraint({ name: 'membershipYearImmutable', async: false })
export class MembershipYearImmutableValidator
  implements ValidatorConstraintInterface
{
  validate(_value: any, _args?: ValidationArguments): boolean {
    // This validator is used in UPDATE DTOs to prevent membership_year changes
    // If this field is present in an update DTO, it's a validation error
    // The service layer will enforce this more strictly

    // For now, if the field is present and different from original, fail
    // Actual comparison would need original entity from database
    // This is a placeholder - real validation happens at service layer
    return true;
  }

  defaultMessage(): string {
    return 'Membership year cannot be changed after creation - it is immutable';
  }
}

/**
 * Validator for User-Year Uniqueness (Business Rule)
 * This would typically be used in service layer for create/update operations
 */
@ValidatorConstraint({ name: 'userYearUniqueEmployment', async: true })
export class UserYearUniqueEmploymentValidator
  implements ValidatorConstraintInterface
{
  validate(): Promise<boolean> {
    // This validator would need repository access to check uniqueness
    // Implementation would be completed when repository layer is available
    // For now, return true (actual validation will be in service layer)
    return Promise.resolve(true);
  }

  defaultMessage(): string {
    return 'An employment record already exists for this user and year combination';
  }
}
