/**
 * Contact Orchestrator Demo Service
 *
 * Simplified demonstration showing the orchestrator pattern and workflow coordination.
 * This service demonstrates the core concepts without complex service integrations.
 *
 * Key Patterns Demonstrated:
 * - Session-based workflow management
 * - Redis integration for state persistence
 * - Step-by-step workflow coordination
 * - Error handling and retry logic
 * - Batch processing patterns
 * - Status tracking and monitoring
 * - Professional networking insights
 * - Social media profile handling
 *
 * Note: This is a demonstration service focusing on orchestrator patterns.
 * Production implementation would integrate with actual business services.
 */

import { Injectable, Logger } from '@nestjs/common';
import { CreateContactDto } from '../../dtos/create-contact.dto';
import { RedisService } from '../../../../../redis/redis.service';
import {
  ContactOrchestrator,
  ContactStagingResult,
  ContactValidationResult,
  ContactPersistenceResult,
} from '../interfaces/contact-orchestrator.interface';

/**
 * Temporary interface for workflow status
 */
interface ContactWorkflowStatus {
  sessionId: string;
  accountGuid?: string;
  currentStep: string;
  progress: Record<string, boolean>;
  nextStep: string;
  statusHistory: Array<{
    step: string;
    timestamp: Date;
    success: boolean;
    details?: string;
  }>;
  socialMediaAnalysis?: {
    platforms: string[];
    profilesFound: number;
    normalizedUrls: Record<string, string>;
  };
  professionalInsights?: {
    jobTitleCategory: string;
    experienceLevel: string;
    networkingPotential: number;
  };
  createdAt: Date;
  lastUpdated: Date;
}
interface ContactSession {
  sessionId: string;
  accountGuid?: string;
  currentStep: 'staging' | 'validation' | 'persistence' | 'complete' | 'failed';
  originalData: CreateContactDto;
  validatedData?: CreateContactDto;
  socialMediaData?: {
    profiles: Record<string, string>;
    normalizedUrls: Record<string, string>;
  };
  networkingInsights?: {
    jobTitleCategory: string;
    experienceLevel: string;
    networkingPotential: number;
  };
  progress: {
    staged: boolean;
    validated: boolean;
    persisted: boolean;
    completed: boolean;
    socialMediaAnalyzed?: boolean;
    businessIdGenerated?: boolean;
  };
  statusHistory: Array<{
    step: string;
    timestamp: Date;
    success: boolean;
    details?: string;
  }>;
  createdAt: Date;
  lastUpdated: Date;
  expiresAt: Date;
  retryCount?: number;
  lastError?: string;
}

/**
 * Simplified Contact Orchestrator Demo
 *
 * Demonstrates workflow coordination patterns without complex service dependencies.
 * Focus is on orchestrator architecture, Redis session management, and workflow state.
 */
@Injectable()
export class ContactOrchestratorDemoService
  implements Partial<ContactOrchestrator>
{
  private readonly logger = new Logger(ContactOrchestratorDemoService.name);
  private readonly SESSION_PREFIX = 'contact:session:';
  private readonly BATCH_PREFIX = 'contact:batch:';
  private readonly DEFAULT_TTL = 7200; // 2 hours

  constructor(private readonly redisService: RedisService) {}

  /**
   * Demo: Contact Staging with Session Management
   * Shows how orchestrator manages workflow state in Redis
   */
  async stageContact(
    contactData: CreateContactDto,
    accountGuid: string,
    options: {
      skipInitialValidation?: boolean;
      sessionTtl?: number;
      registrationFlow?: 'web' | 'mobile' | 'api';
    } = {},
  ): Promise<ContactStagingResult> {
    this.logger.log('Demo: Staging contact with session management');

    try {
      // Generate unique session identifier
      const sessionId = this.generateSessionId();
      const now = new Date();
      const expiresAt = new Date(
        now.getTime() + (options.sessionTtl || this.DEFAULT_TTL) * 1000,
      );

      // Create workflow session
      const session: ContactSession = {
        sessionId,
        accountGuid,
        currentStep: 'staging',
        originalData: contactData,
        progress: {
          staged: false,
          validated: false,
          persisted: false,
          completed: false,
          businessIdGenerated: false, // Business ID is auto-generated by Dataverse
        },
        statusHistory: [
          {
            step: 'staging_initiated',
            timestamp: now,
            success: true,
            details: 'Contact staging process initiated',
          },
        ],
        createdAt: now,
        lastUpdated: now,
        expiresAt,
      };

      // Store session in Redis
      await this.storeSession(session);

      // Update progress to staged
      session.progress.staged = true;
      session.statusHistory.push({
        step: 'staging_completed',
        timestamp: new Date(),
        success: true,
        details: 'Contact successfully staged for validation',
      });
      await this.updateSession(session);

      this.logger.log(
        `Demo: Contact staged successfully with session: ${sessionId}`,
      );

      return {
        sessionId,
        status: 'staged',
        contactData,
        businessId: 'auto-generated', // Business ID will be auto-generated by Dataverse
        socialMediaProfiles: {
          facebook: contactData.osot_facebook,
          instagram: contactData.osot_instagram,
          tiktok: contactData.osot_tiktok,
          linkedin: contactData.osot_linkedin,
        },
        nextStep: 'validation',
        validationWarnings: options.skipInitialValidation
          ? []
          : ['Demo warning: Initial validation skipped'],
        expiresAt,
      };
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : 'Unknown error';
      const errorStack = error instanceof Error ? error.stack : undefined;

      this.logger.error(
        `Demo: Contact staging failed: ${errorMessage}`,
        errorStack,
      );
      throw new Error(`Contact staging failed: ${errorMessage}`);
    }
  }

  /**
   * Demo: Contact Validation with Business Logic Simulation
   * Shows validation workflow coordination and session updates
   */
  async validateContact(
    sessionId: string,
    options: {
      applyNormalization?: boolean;
      strictValidation?: boolean;
      analyzeSocialMedia?: boolean;
    } = {},
  ): Promise<ContactValidationResult> {
    this.logger.log(`Demo: Validating contact for session: ${sessionId}`);

    const session = await this.getSession(sessionId);
    if (!session) {
      throw new Error('Contact session not found or expired');
    }

    try {
      // Demo validation logic - Account binding is the main required field
      const hasErrors = !session.originalData['osot_Table_Account@odata.bind']; // Basic required fields

      // Demo social media analysis
      if (options.analyzeSocialMedia) {
        session.socialMediaData = {
          profiles: {
            facebook: session.originalData.osot_facebook || '',
            instagram: session.originalData.osot_instagram || '',
            linkedin: session.originalData.osot_linkedin || '',
            tiktok: session.originalData.osot_tiktok || '',
          },
          normalizedUrls: {
            facebook: session.originalData.osot_facebook || '',
            instagram: session.originalData.osot_instagram || '',
            linkedin: session.originalData.osot_linkedin || '',
            tiktok: session.originalData.osot_tiktok || '',
          },
        };
        session.progress.socialMediaAnalyzed = true;
      }

      // Demo professional networking insights
      if (session.originalData.osot_job_title) {
        session.networkingInsights = {
          jobTitleCategory: this.categorizeJobTitle(
            session.originalData.osot_job_title,
          ),
          experienceLevel: this.estimateExperienceLevel(
            session.originalData.osot_job_title,
          ),
          networkingPotential: session.originalData.osot_linkedin ? 85 : 45,
        };
      }

      const normalizedData = options.applyNormalization
        ? {
            ...session.originalData,
            // osot_user_business_id is auto-generated by Dataverse
            osot_secondary_email: session.originalData.osot_secondary_email
              ?.toLowerCase()
              .trim(),
          }
        : session.originalData;

      const validationResults = {
        businessIdUnique: true, // Demo: assume business ID is unique
        socialMediaNormalized: !!options.analyzeSocialMedia,
        emailValid: this.isValidEmail(
          session.originalData.osot_secondary_email || '',
        ),
        phoneValid: true, // Demo: assume phone is valid
        businessRulesApplied: [
          'demo_contact_required_fields',
          'demo_business_id_format',
          'demo_normalization',
        ],
        professionalNetworking: {
          jobTitleAnalyzed: !!session.originalData.osot_job_title,
          industryDetected: !!session.originalData.osot_job_title,
          experienceLevelEstimated: !!session.originalData.osot_job_title,
        },
        warnings: options.strictValidation
          ? ['Demo: Strict validation enabled']
          : [],
        errors: hasErrors ? ['Demo: Missing required fields'] : [],
      };

      const status = hasErrors ? 'validation_failed' : 'validated';

      // Update session with validation results
      session.validatedData = normalizedData;
      session.currentStep = hasErrors ? 'failed' : 'validation';
      session.progress.validated = !hasErrors;
      session.statusHistory.push({
        step: 'validation_completed',
        timestamp: new Date(),
        success: !hasErrors,
        details: hasErrors
          ? 'Validation failed'
          : 'Contact validation successful',
      });
      session.lastUpdated = new Date();

      await this.updateSession(session);

      this.logger.log(
        `Demo: Contact validation completed: ${sessionId}, status: ${status}`,
      );

      return {
        sessionId,
        status,
        originalData: session.originalData,
        normalizedData: options.applyNormalization ? normalizedData : undefined,
        validationResults,
        nextStep: hasErrors ? 'retry_validation' : 'persistence',
        validatedAt: new Date(),
      };
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : 'Unknown error';
      const errorStack = error instanceof Error ? error.stack : undefined;

      this.logger.error(
        `Demo: Contact validation failed for ${sessionId}: ${errorMessage}`,
        errorStack,
      );

      // Update session with error
      session.currentStep = 'failed';
      session.lastError = errorMessage;
      await this.updateSession(session);

      throw new Error(`Contact validation failed: ${errorMessage}`);
    }
  }

  /**
   * Demo: Contact Persistence with Mock Dataverse Integration
   * Shows how orchestrator coordinates final persistence step
   */
  async persistContact(
    sessionId: string,
    accountGuid: string,
  ): Promise<ContactPersistenceResult> {
    this.logger.log(
      `Demo: Persisting contact for session: ${sessionId}, account: ${accountGuid}`,
    );

    const session = await this.getSession(sessionId);
    if (!session || !session.validatedData) {
      throw new Error('Contact session not found or not validated');
    }

    try {
      // Demo persistence - in production this would call ContactCrudService
      const mockContactId = `ct-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`;
      const mockBusinessId = `CONT-${String(Date.now()).slice(-6)}`; // Simulated auto-generated ID

      // Update session with persistence results
      session.accountGuid = accountGuid;
      session.currentStep = 'complete';
      session.progress.persisted = true;
      session.progress.completed = true;
      session.statusHistory.push({
        step: 'persistence_completed',
        timestamp: new Date(),
        success: true,
        details: `Demo: Contact persisted with mock ID: ${mockContactId}`,
      });
      session.lastUpdated = new Date();

      await this.updateSession(session);

      this.logger.log(
        `Demo: Contact persisted successfully with mock ID: ${mockContactId}`,
      );

      return {
        sessionId,
        accountGuid,
        contactId: mockContactId,
        businessId: mockBusinessId,
        status: 'active',
        socialMediaSummary: {
          totalProfiles: session.socialMediaData
            ? Object.values(session.socialMediaData.profiles).filter(Boolean)
                .length
            : 0,
          platforms: session.socialMediaData
            ? Object.keys(session.socialMediaData.profiles).filter(
                (platform) => session.socialMediaData?.profiles[platform],
              )
            : [],
          normalizedUrls: session.socialMediaData?.normalizedUrls || {},
        },
        communicationPreferences: {
          hasEmail: !!session.originalData.osot_secondary_email,
          hasPhone: !!(
            session.originalData.osot_home_phone ||
            session.originalData.osot_work_phone
          ),
          hasWebsite: !!session.originalData.osot_business_website,
          preferredMethod: session.originalData.osot_secondary_email
            ? 'email'
            : session.originalData.osot_home_phone ||
                session.originalData.osot_work_phone
              ? 'phone'
              : 'unknown',
        },
        nextStep: 'complete',
        persistedAt: new Date(),
      };
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : 'Unknown error';
      const errorStack = error instanceof Error ? error.stack : undefined;

      this.logger.error(
        `Demo: Contact persistence failed for ${sessionId}: ${errorMessage}`,
        errorStack,
      );

      // Update session with error
      session.currentStep = 'failed';
      session.lastError = errorMessage;
      await this.updateSession(session);

      throw new Error(`Contact persistence failed: ${errorMessage}`);
    }
  }

  /**
   * Demo: Workflow Status Tracking
   * Shows comprehensive workflow state monitoring
   */
  async getWorkflowStatus(
    sessionId: string,
  ): Promise<ContactWorkflowStatus | null> {
    const session = await this.getSession(sessionId);
    if (!session) {
      return null;
    }

    return {
      sessionId: session.sessionId,
      accountGuid: session.accountGuid,
      currentStep: session.currentStep,
      progress: {
        ...session.progress,
        normalized: !!session.validatedData,
        linked: !!session.accountGuid,
        professionalProfileAnalyzed: !!session.networkingInsights,
      },
      nextStep: this.determineNextStep(session),
      statusHistory: session.statusHistory,
      socialMediaAnalysis: session.socialMediaData
        ? {
            platforms: Object.keys(session.socialMediaData.profiles).filter(
              (platform) => session.socialMediaData?.profiles[platform],
            ),
            profilesFound: Object.values(
              session.socialMediaData.profiles,
            ).filter(Boolean).length,
            normalizedUrls: session.socialMediaData.normalizedUrls,
          }
        : undefined,
      professionalInsights: session.networkingInsights,
      createdAt: session.createdAt,
      lastUpdated: session.lastUpdated,
    };
  }

  /**
   * Demo: Validation Rules Retrieval
   * Shows how orchestrator provides business rule information
   */
  getValidationRules(): Promise<any> {
    this.logger.log('Demo: Retrieving validation rules');

    return Promise.resolve({
      contactTypes: [
        { id: 0, name: 'Primary' },
        { id: 1, name: 'Alternate' },
        { id: 2, name: 'Emergency' },
      ],
      requiredFields: ['firstName', 'lastName', 'email'],
      businessRules: {
        uniqueEmailPerAccount: true,
        maxContactsPerAccount: 10,
        requiredPrimaryContact: true,
        socialMediaValidation: {
          supportedPlatforms: ['facebook', 'instagram', 'linkedin', 'tiktok'],
          urlPatterns: {
            facebook: '^https://(www\\.)?facebook\\.com/',
            instagram: '^https://(www\\.)?instagram\\.com/',
            linkedin: '^https://(www\\.)?linkedin\\.com/',
            tiktok: '^https://(www\\.)?tiktok\\.com/',
          },
        },
        professionalNetworking: {
          jobTitleCategories: [
            'Software Development',
            'Marketing',
            'Sales',
            'Management',
            'Other',
          ],
          experienceLevels: ['entry', 'mid', 'senior', 'executive'],
        },
      },
    });
  }

  /**
   * Demo: Session Cleanup
   * Shows maintenance operations for expired sessions
   */
  cleanupExpiredSessions(olderThanHours = 24): Promise<{
    cleanedSessions: number;
    cleanedBatches: number;
  }> {
    this.logger.log(
      `Demo: Cleaning up sessions older than ${olderThanHours} hours`,
    );

    // Demo implementation - production would use Redis SCAN
    return Promise.resolve({
      cleanedSessions: Math.floor(Math.random() * 10), // Random demo count
      cleanedBatches: Math.floor(Math.random() * 3),
    });
  }

  /**
   * Demo: Workflow Resume
   * Shows error recovery and workflow continuation
   */
  async resumeWorkflow(sessionId: string): Promise<ContactWorkflowStatus> {
    this.logger.log(`Demo: Resuming workflow for session: ${sessionId}`);

    const session = await this.getSession(sessionId);
    if (!session) {
      throw new Error('Session not found for resume');
    }

    // Reset error state and attempt to continue
    session.retryCount = (session.retryCount || 0) + 1;
    session.lastError = undefined;
    session.lastUpdated = new Date();
    session.statusHistory.push({
      step: 'workflow_resumed',
      timestamp: new Date(),
      success: true,
      details: `Workflow resume attempt #${session.retryCount}`,
    });

    await this.updateSession(session);

    const status = await this.getWorkflowStatus(sessionId);
    if (!status) {
      throw new Error('Failed to retrieve workflow status after resume');
    }

    return status;
  }

  /**
   * PRIVATE HELPER METHODS
   * Internal utilities for session and workflow management
   */

  private generateSessionId(): string {
    return `contact_${Date.now()}_${Math.random().toString(36).substr(2, 8)}`;
  }

  private async storeSession(session: ContactSession): Promise<void> {
    const key = this.SESSION_PREFIX + session.sessionId;
    const serializedSession = JSON.stringify(session, (key, value) => {
      if (value instanceof Date) {
        return value.toISOString();
      }
      return value as unknown;
    });
    await this.redisService.set(key, serializedSession);
  }

  private async getSession(sessionId: string): Promise<ContactSession | null> {
    try {
      const key = this.SESSION_PREFIX + sessionId;
      const sessionData = await this.redisService.get(key);
      if (!sessionData) return null;

      const parsed = JSON.parse(sessionData, (key, value) => {
        if (
          typeof value === 'string' &&
          /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}.\d{3}Z$/.test(value)
        ) {
          return new Date(value);
        }
        return value as unknown;
      }) as ContactSession;
      return parsed;
    } catch (error) {
      this.logger.warn(
        `Demo: Failed to retrieve session ${sessionId}: ${
          error instanceof Error ? error.message : 'Unknown error'
        }`,
      );
      return null;
    }
  }

  private async updateSession(session: ContactSession): Promise<void> {
    session.lastUpdated = new Date();
    await this.storeSession(session);
  }

  private determineNextStep(session: ContactSession): string {
    switch (session.currentStep) {
      case 'staging':
        return 'validation';
      case 'validation':
        return session.progress.validated ? 'persistence' : 'retry_validation';
      case 'persistence':
        return session.accountGuid ? 'complete' : 'waiting_for_account_guid';
      case 'complete':
        return 'workflow_complete';
      case 'failed':
        return session.retryCount && session.retryCount < 3
          ? 'retry_available'
          : 'manual_intervention_required';
      default:
        return 'unknown_state';
    }
  }

  private isValidEmail(email: string): boolean {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
  }

  private isBusinessEmail(email: string): boolean {
    const personalDomains = [
      'gmail.com',
      'yahoo.com',
      'hotmail.com',
      'outlook.com',
    ];
    const domain = email.split('@')[1];
    return !personalDomains.includes(domain?.toLowerCase() || '');
  }

  private categorizeJobTitle(jobTitle: string): string {
    const title = jobTitle.toLowerCase();
    if (
      title.includes('developer') ||
      title.includes('engineer') ||
      title.includes('programmer')
    ) {
      return 'Software Development';
    }
    if (title.includes('marketing') || title.includes('brand')) {
      return 'Marketing';
    }
    if (title.includes('sales') || title.includes('account')) {
      return 'Sales';
    }
    if (
      title.includes('manager') ||
      title.includes('director') ||
      title.includes('ceo') ||
      title.includes('cto')
    ) {
      return 'Management';
    }
    return 'Other';
  }

  private estimateExperienceLevel(jobTitle: string): string {
    const title = jobTitle.toLowerCase();
    if (
      title.includes('junior') ||
      title.includes('entry') ||
      title.includes('intern')
    ) {
      return 'entry';
    }
    if (title.includes('senior') || title.includes('lead')) {
      return 'senior';
    }
    if (
      title.includes('director') ||
      title.includes('vp') ||
      title.includes('ceo') ||
      title.includes('cto')
    ) {
      return 'executive';
    }
    return 'mid';
  }
}
